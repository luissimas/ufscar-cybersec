# Write-up Union CTF 2021 - Cr0wnAir

## JWT
JSON web token é um esquema de tokens para a transferência de dados no formato JSON, em que eles são criptografados e mantidos pelo cliente. É um padrão muito popular em processos de autenticação, gerenciamento de sessões e mecanismos de controle de acesso. 

![](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fsupertokens.com%2Fstatic%2Fb0172cabbcd583dd4ed222bdb83fc51a%2F9af93%2Fjwt-structure.png&f=1&nofb=1&ipt=740b0c69be0f976e67dac531e7e2d3c08fe8bd1202acb08e10eca5a89e5391c8&ipo=images)

## Desafio
Cr0wn is getting into the airline business to make some sweet profits when everyone is able to travel again. Can you upgrade your trip?

Attachments: `Cr0wnAir.zip`

### Novo servidor
http://cybersec-ufscar.duckdns.org:3000/

## Contexto
A partir do código fonte disponibilizado percebemos que o sistema deve receber um token identificando o cliente na classe "gold"

```javascript
router.post('/flag', [getLoyaltyStatus], function(req, res, next) {
  if (res.locals.token && res.locals.token.status == "gold") {
    var response = {msg: config.flag };
  } else {
    var response = {msg: "You do not qualify for this upgrade at this time. Please fly with us more."};
  }
  res.json(response);
});
```

Então a partir dos dados inseridos no check in, devemos gerar um token que se encaixe nessa classe:

```javascript
const pattern = {
  firstName: /^\w{1,30}$/,
  lastName: /^\w{1,30}$/,
  passport: /^[0-9]{9}$/,
  ffp: /^(|CA[0-9]{8})$/,
  extras: [
    {sssr: /^(BULK|UMNR|VGML)$/},
  ],
};
// ...
router.post('/checkin', function(req, res, next) {
  if (!req.body) return res.sendStatus(400);
  var data = req.body;
  if (jpv.validate(data, pattern, { debug: true, mode: "strict" })) {
    if (data["firstName"] == "Tony" && data["lastName"] == "Abbott") {
      var response = {msg: "You have successfully checked in! Please remember not to post your boarding pass on social media."};
    } else if (data["ffp"]) {
      var response = {msg: "You have successfully checked in. Thank you for being a Cr0wnAir frequent flyer."};
      for(e in data["extras"]) {
        if (data["extras"][e]["sssr"] && data["extras"][e]["sssr"] === "FQTU") {
          var token = createToken(data["passport"], data["ffp"]);
          var response = {msg: "You have successfully checked in. Thank you for being a Cr0wnAir frequent flyer. Your loyalty has been rewarded and you have been marked for an upgrade, please visit the upgrades portal.", "token": token};
        }
      }
    } else {
      var response = {msg: "You have successfully checked in!"};
    }
  } else {
    var response = {msg: "Invalid checkin data provided, please try again."};
  }

  res.json(response);
});
```

## Resolução
Devemos verificar quais bibliotecas são usadas nesse site para encontrarmos vulnerabilidades de acordo com suas versões:

```json
"dependencies": {
    "express": "4.17.1",
    "jpv": "2.0.1",
    "jwt-simple": "0.5.2"
}
```

Ao pesquisarmos sobre elas encontramos as seguintes vulnerabilidades:

[jpv issue - validate bypass](https://github.com/manvel-khnkoyan/jpv/issues/6)

[jwt issue - key algorithm is undefined](https://github.com/hokaccha/node-jwt-simple/pull/86/commits/ead36e1d687645da9c3be8befdaaef622ea33106)
[Abusing JWT public keys without the public key](https://blog.silentsignal.eu/2021/02/08/abusing-jwt-public-keys-without-the-public-key/) 

A partir disso podemos enviar quaisquer dados no check in, mas no campo de extras precisamos colocar `”sssr”:”FQTU”` e `”constructor”:{”name”:”Array”}` já que para acessar os benefícios gold (a flag) o código faz a seguinte verificação:

```javascript
if (data["extras"][e]["sssr"] && data["extras"][e]["sssr"] === "FQTU") {
  var token = createToken(data["passport"], data["ffp"]);
  var response = {msg: "You have successfully checked in. Thank you for being a Cr0wnAir frequent flyer. Your loyalty has been rewarded and you have been marked for an upgrade, please visit the upgrades portal.", "token": token};
 }
```

Assim conseguimos receber um token, mas ele não vai ser aceito ainda, para isso vamos usar a vulnerabilidade encontrada na biblioteca jwt-simple, que não especifica qual o algoritmo que encriptou o token, assim podemos trocar para um algoritmo simétrico a partir da chave RSA pública, que infelizmente não temos acesso. Para conseguirmos a chave pública vamos obter dois tokens diferentes e usar elas em um programa direcionado para atacar essa vulnerabilidade que a partir das assinaturas dos tokens encontra a chave pública, levando em conta o payload que especificarmos, no caso incluir a classe gold. 

Com isso geramos um JWT forjado com uma assinatura HMAC (simétrica), que ao ser enviado para o servidor, é aceito como uma requisição válida e finalmente obtemos a flag do desafio:

`union{I_<3_JS0N_4nD_th1ngs_wr4pp3d_in_JS0N}`

## Como corrigir a vulnerabilidade
Nesse desafio, as duas vulnerabilidades exploradas estavam em versões desatualizadas das bibliotecas utilizadas. Essas vulnerabilidades se resumem a:

1. Validação incorreta dos dados do usuário, permitindo a geração arbitrária de tokens JWT
2. O processo de decode do JWT não seta o algoritmo de assinatura explicitamente, fazendo fallback para o algoritmo incluído no header do token

Como o ataque depende dessas duas vulnerabilidades encadeadas, se qualquer uma delas for corrigida, o ataque não seria possível.

## Referências
https://www.kalmarunionen.dk/writeups/2021/union-ctf-2021/cr0wnair/

https://github.com/qxxxb/ctf/tree/master/2021/union_ctf/Cr0wnAir

https://github.com/TheWinRaRs/Writeups/blob/master/2021-writeups/union-ctf/cr0wn-air.md

https://sectt.github.io/writeups/UnionCTF21/web_cr0wnair/README

https://www.youtube.com/watch?v=bHF-uOIaM-o

https://www.akamai.com/pt/blog/security-research/owasp-authentication-threats-for-json-web-token

https://portswigger.net/web-security/jwt
